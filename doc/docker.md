# Docker 및 컨테이너 핵심 개념 정리

---

## 1. 가상머신(VM)과 컨테이너(Container)의 차이 : 가상머신과 컨테이너는 애플리케이션을 격리된 환경에서 실행한다는 공통점이 있지만, 격리 수준과 아키텍처에서 근본적인 차이가 있습니다.

### 가상머신 (Virtual Machine) - 가상머신은 **하드웨어 가상화** 방식을 사용합니다. 물리적 컴퓨터 위에 하이퍼바이저(Hypervisor)라는 소프트웨어를 설치하여, 여러 개의 독립된 가상 컴퓨터를 만듭니다.

* **아키텍처**: 각 가상머신은 하드웨어부터 운영체제(Guest OS)까지 **모든 것을 포함하는 완전한 컴퓨터 형태**입니다.
* **격리 수준**: 하드웨어 수준에서 완벽하게 격리되어, 한 가상머신의 문제가 다른 가상머신에 영향을 주지 않아 **보안성이 매우 높습니다.**
* **효율성**: 각자 독립된 OS를 가지므로 크기가 **수 GB 이상**으로 크고, 부팅에 수 분이 소요되어 **무겁고 느립니다.**
* **핵심 기술**: VMware, VirtualBox와 같은 **하이퍼바이저(Hypervisor)**가 가상화를 담당합니다.

### 컨테이너 (Container) - 컨테이너는 **OS 수준 가상화** 방식을 사용합니다. 호스트(Host) 컴퓨터의 운영체제(OS) 커널을 공유하며, 애플리케이션과 그 종속성만 격리하여 실행합니다.

* **아키텍처**: OS 커널을 공유하므로 **Guest OS가 필요 없습니다.** 애플리케이션과 실행에 필요한 라이브러리만으로 구성됩니다.
* **격리 수준**: 프로세스 단위로 격리됩니다. 가상머신보다 격리 수준은 낮지만, 실행 환경을 분리하기엔 충분합니다.
* **효율성**: OS를 포함하지 않아 용량이 **수십 ~ 수백 MB**로 매우 작고, 프로세스를 실행하는 것처럼 **수 초 내로 빠르게** 시작됩니다.
* **핵심 기술**: Docker, containerd와 같은 **컨테이너 런타임(Container Runtime)**이 실행을 담당합니다.

**결론적으로** 가상머신은 **컴퓨터 자체를 가상화**하는 무거운 기술인 반면, 컨테이너는 **OS의 자원을 공유하며 프로세스만 격리**하는 훨씬 가볍고 빠른 기술입니다.

---

## 2. 컨테이너(Container)와 이미지(Image)의 차이 - 컨테이너와 이미지는 클래스와 인스턴스의 관계와 유사합니다. 이미지는 '설계도'이고, 컨테이너는 그 설계도로 만들어진 '실행 인스턴스'입니다.

* **이미지 (Image):**
    * **정의:** 컨테이너를 실행하기 위한 모든 정보(애플리케이션 코드, 런타임, 시스템 도구, 라이브러리 등)를 담고 있는 **읽기 전용(Read-only) 템플릿**입니다.
    * **특징:**
        * 상태가 없는(Stateless) 불변(Immutable)의 파일 묶음입니다.
        * 한 번 빌드되면 내용이 변하지 않습니다.
        * 여러 개의 레이어(Layer)로 구성됩니다.

* **컨테이너 (Container):**
    * **정의:** 이미지의 **실행 가능한 인스턴스(Runnable Instance)**입니다.
    * **특징:**
        * 호스트 OS와 격리된 독립적인 공간에서 프로세스로 실행됩니다.
        * 이미지 레이어 위에 **쓰기 가능한(Writable) 컨테이너 레이어**를 추가하여 실행 중에 생성되거나 변경된 데이터를 저장합니다.
        * 컨테이너가 삭제되면 이 쓰기 가능한 레이어도 함께 사라집니다 (데이터는 보존되지 않음).
        * 하나의 이미지로 수많은 컨테이너를 생성하고 실행할 수 있습니다.

**핵심 비유:** 이미지가 **프로그램의 설치 파일(e.g., `setup.exe`)**이라면, 컨테이너는 **설치 후 실행된 프로그램 그 자체**입니다.

---

## 3. 컨테이너 런타임(Container Runtime)의 정의 - **컨테이너 런타임**은 컨테이너의 생명주기(Life Cycle)를 관리하는 핵심 구성 요소입니다. 즉, 이미지를 가져오고, 컨테이너를 실제로 생성, 실행, 중지, 삭제하는 역할을 수행하는 소프트웨어입니다. 과거에는 Docker 엔진이 모든 역할을 했지만, 현재는 OCI(Open Container Initiative) 표준에 따라 역할이 분리되었습니다.

* **고수준 런타임 (High-level Runtime):**
    * 사용자 친화적인 API를 제공하며 이미지 전송, 압축 해제, 컨테이너 실행 상태 관리 등을 담당합니다.
    * 예: `containerd`, `CRI-O`

* **저수준 런타임 (Low-level Runtime):**
    * 실질적으로 컨테이너를 생성하고 실행하는 역할을 합니다. 리눅스 네임스페이스(Namespace)나 컨트롤 그룹(cgroups) 같은 커널 기능을 직접 호출합니다.
    * 예: `runc`

Docker를 예로 들면, 사용자가 `docker run` 명령어를 입력하면 Docker 데몬이 `containerd`(고수준 런타임)를 호출하고, `containerd`가 `runc`(저수준 런타임)를 호출하여 컨테이너를 실행하는 구조입니다.

---

## 4. CNCF Landscape 기반 컨테이너 런타임 종류 - [CNCF(Cloud Native Computing Foundation)의 Cloud Native Interactive Landscape](https://landscape.cncf.io/)의 **Container Runtime** 섹션에서 확인할 수 있는 주요 컨테이너 런타임은 다음과 같습니다.

1.  **containerd:**
    * Docker에서 분리되어 독립된 프로젝트로 발전했으며, 현재는 CNCF의 졸업(Graduated) 프로젝트입니다.
    * 단순성, 견고함, 이식성을 목표로 하며, 쿠버네티스(Kubernetes) 환경에서 사실상의 표준으로 사용됩니다.

2.  **CRI-O:**
    * 쿠버네티스를 위해 특별히 만들어진 경량 컨테이너 런타임입니다.
    * 쿠버네티스의 CRI(Container Runtime Interface) 사양을 충족하는 데에만 집중하며, Docker와 같은 부가 기능이 없습니다. Red Hat이 주도하여 개발했습니다.

3.  **runC:**
    * OCI(Open Container Initiative) 컨테이너 런타임 사양을 따르는 가장 기본적인 저수준 컨테이너 런타임입니다.
    * `containerd`나 `CRI-O`와 같은 고수준 런타임의 내부에서 컨테이너를 실행하는 데 사용됩니다. 그 자체로 완전한 컨테이너 관리 플랫폼은 아닙니다.

---

## 5. 도커 이미지의 레이어(Layer) - 도커 이미지는 단일 파일이 아니라, 여러 개의 **읽기 전용(Read-only) 레이어**가 투명하게 겹쳐진 형태로 구성됩니다. 이는 이미지의 효율성을 극대화하는 핵심적인 특징입니다.

* **레이어의 생성:**
    * `Dockerfile`의 각 명령어(`FROM`, `RUN`, `COPY`, `ADD` 등)는 하나의 레이어를 생성합니다.
    * 각 레이어는 이전 레이어에서의 변경 사항만을 담고 있습니다.

* **레이어의 구조와 특징:**
    * **스택 구조:** 레이어들은 순서대로 차곡차곡 쌓입니다. 베이스 이미지(e.g., `ubuntu`) 위에 새로운 레이어들이 추가되는 방식입니다.
    * **불변성 (Immutability):** 한 번 생성된 레이어는 절대 변경되지 않습니다. 만약 특정 파일을 수정하면, 기존 레이어는 그대로 둔 채 새로운 레이어가 생성되어 그 위에 덮어씁니다.
    * **공유:** 여러 이미지가 동일한 레이어를 공유할 수 있습니다. 예를 들어, `ubuntu`를 기반으로 하는 10개의 다른 이미지가 있다면, `ubuntu`에 해당하는 레이어들은 디스크에 단 한 번만 저장되고 10개의 이미지가 이를 공유합니다. 이는 스토리지 공간을 크게 절약합니다.

* **Copy-on-Write (CoW) 전략:**
    * 컨테이너를 실행하면, 기존 이미지 레이어들 위에는 **쓰기 가능한 '컨테이너 레이어'**가 추가됩니다.
    * 컨테이너 내부에서 파일을 읽을 때는 아래쪽의 이미지 레이어에서 데이터를 가져옵니다.
    * 컨테이너 내부에서 파일을 수정하거나 새로운 파일을 생성하면, 변경 사항은 가장 위쪽의 '컨테이너 레이어'에 기록됩니다. 원본 이미지 레이어는 절대 수정되지 않습니다.
    * 이러한 방식으로 하나의 이미지로 수많은 컨테이너를 빠르고 효율적으로 생성할 수 있습니다.