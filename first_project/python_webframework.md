문제 1. 

### 1. Django (장고) - 하나의 프레임워크로 모든 것을 해결하

장고의 핵심 철학은 **Batteries-included**입니다. 이는 웹 개발에 필요한 대부분의 도구와 기능이 프레임워크 자체에 내장되어 있어, 개발자가 별도의 라이브러리를 찾고 조합하는 수고를 덜어준다는 의미입니다. 개발 속도가 매우 빠르며, 정해진 구조와 규칙(Convention over Configuration)을 따르기 때문에 코드의 일관성과 안정성이 높습니다.

핵심 특징
1. 강력한 ORM (Object-Relational Mapper): SQL 쿼리문을 직접 작성하지 않고 파이썬 클래스와 객체를 통해 데이터베이스를 조작할 수 있습니다. 복잡한 데이터 관계를 직관적으로 다룰 수 있으며, 데이터베이스 종류가 바뀌어도 코드를 거의 수정할 필요가 없습니다.
2. 자동 관리자 페이지 (Admin Interface): 장고의 가장 독보적인 기능입니다. 모델(데이터베이스 테이블)을 정의하기만 하면, 별도의 코딩 없이 데이터를 관리(생성, 조회, 수정, 삭제)할 수 있는 완성도 높은 관리자 웹페이지가 자동으로 생성됩니다.
3. 내장된 보안 기능: SQL 인젝션, 사이트 간 스크립팅(XSS), 클릭재킹(Clickjacking) 등 일반적인 웹 공격에 대한 방어 기능이 기본적으로 탑재되어 있어 보안성이 높습니다.
4. MVT 아키텍처 (Model-View-Template): 데이터(Model), 로직(View), 화면(Template)을 명확하게 분리하는 설계 구조를 가지고 있어 코드의 역할 구분이 명확하고 유지보수가 용이합니다.

주요 사용처: 대규모 커뮤니티 사이트, 전자상거래 플랫폼, 복잡한 관리 시스템, 콘텐츠 관리 시스템(CMS) 등 빠르고 안정적인 개발이 필요한 대부분의 웹 애플리케이션에 적합합니다.
 
### 2. Flask (플라스크) - 내가 원하는 대로 조립하는 가볍고 유연한 마이크로프레임워크

플라스크는 **마이크로프레임워크**를 표방합니다. 이는 웹 서버를 구동하고 요청을 처리하는 핵심 기능에만 집중하고, 그 외의 모든 기능은 개발자가 직접 선택하여 추가하도록 설계되었음을 의미합니다. ORM, 폼 검증, 사용자 인증 같은 기능이 내장되어 있지 않아 처음에는 매우 가볍습니다.

핵심 특징
1. 최소주의와 유연성: 프레임워크 자체의 규칙이 거의 없어 개발자가 프로젝트의 구조와 사용할 기술을 매우 자유롭게 결정할 수 있습니다. 이는 간단한 API부터 복잡한 웹 애플리케이션까지 다양한 형태로 확장이 가능하다는 장점이 됩니다.
2. 확장 기능(Extensions): 플라스크 자체는 작지만, 수많은 확장 라이브러리를 통해 필요한 기능을 쉽게 추가할 수 있습니다. 예를 들어, SQLAlchemy로 데이터베이스를 연동하고, Flask-WTF로 폼을 처리하는 식입니다.
3. 직관적인 코드: 코드가 매우 간결하고 직관적이어서 웹 프레임워크의 작동 원리를 이해하고 배우기에 적합합니다. 라우팅(URL 연결) 규칙을 데코레이터(@app.route('/'))를 사용해 함수에 직접 명시하므로 가독성이 높습니다.
4. 핵심 의존성 (Werkzeug & Jinja2): 강력한 웹 서버 게이트웨이 인터페이스(WSGI) 유틸리티인 Werkzeug와 유연한 템플릿 엔진인 Jinja2를 기반으로 동작하여 안정성과 확장성을 모두 확보했습니다.

주요 사용처: 소규모 웹 서비스, 간단한 REST API 서버, 사내 도구, 프로토타입 제작 등 가볍고 빠르게 시작해야 하거나, 특정 기술 스택에 얽매이지 않고 자유롭게 개발하고 싶은 경우에 적합합니다.

### 3. FastAPI (패스트API) - 현대 파이썬의 장점을 극대화한 고성능 API 서버

FastAPI는 빠른 성능에 초점을 맞춘 최신 웹 프레임워크입니다. 파이썬 3.7 이상부터 도입된 **타입 힌트(Type Hints)**와 비동기(Asyncio) 처리 기능을 적극적으로 활용하여 높은 성능과 뛰어난 개발 경험을 동시에 제공합니다.

핵심 특징
1. 압도적인 성능: 고성능 비동기 프레임워크인 Starlette 위에서 동작하며, 데이터 검증 및 직렬화 라이브러리인 Pydantic을 사용하여 NodeJS나 Go와 견줄 만큼 빠른 처리 속도를 보여줍니다.
2. 자동 대화형 API 문서: 타입 힌트를 기반으로 코드를 작성하기만 하면, Swagger UI와 ReDoc이라는 두 종류의 대화형 API 문서를 자동으로 생성해 줍니다. 이를 통해 별도의 문서 작업 없이 API를 테스트하고 공유할 수 있어 생산성이 극대화됩니다.
3. 타입 힌트와 데이터 검증: 함수의 매개변수와 반환 값에 타입을 명시하면, FastAPI가 요청 데이터를 받을 때 자동으로 데이터의 유효성을 검사하고 타입을 변환해 줍니다. 이는 개발자의 실수를 줄여 코드의 안정성을 크게 높입니다.
4. 의존성 주입 (Dependency Injection): 코드의 재사용성을 높이고 결합도를 낮추는 정교한 의존성 주입 시스템을 내장하고 있어, 데이터베이스 연결, 사용자 인증 등 공통 기능을 쉽게 관리하고 테스트할 수 있습니다.

주요 사용처: 고성능 REST API 서버, 마이크로서비스 아키텍처(MSA), 실시간 웹 애플리케이션, 머신러닝 모델 서빙 등 빠르고 안정적인 API 개발이 필요한 모든 곳에 적합합니다.


문제 2. 
1. Run Without Debugging vs Start Debugging 차이점
    - Run Without Debugging : 애플리케이션 실행의 최종 결과만 확인 할 수 있지만, 상대적으로 속도는 빠르다.
    - Start Debugging : 코드의 오류나 문제점을 분석할 수 있는 정보 및 기능(중단점 설정, 변수 값 실시간 추적, 코드실행흐름등)을 다양하게 제공하지만, 그만큼 상대적으로 속도가 저하된다. 
2. Flask의 역할 요약
    - Flask는 웹 애플리케이션을 쉽고 빠르게 작성할 수 있도록 도와주는 파이썬 프레임워크로서, 복잡한 웹 개발을 단순화해주는 뼈대이자 도구모음이다. 
    - 사용자가 웹 브라우져를 통하여 특정 요청을 하였을 때, 해당 요청을 처리하고 처리한 결과를 다시 사용자에게 응답하는 전체 과정을 관리하는 역할을 하고 있다. 
    - 마이크로프레임워크로 불리며, 프레임워크가 굉장히 가볍고 확장가능성에 대한 유연성을 갖고 있지만, 상대적으로 복잡한 기능을 구현하기 위해서는 개발자가 직접 확장 라이브러리를 찾아서 설치해야하는 번거로움을 갖고있다. 
3. 0.0.0.0으로 설정 시 의미와 장단점
    - 0.0.0.0 설정의 의미는 전체 네트워크 인터페이스(예: 127.0.0.1, 내부 IP, 공인 IP 등)에서 들어오는 요청을 허용한다는 의미가 되며 내부망 노출로 인한 보안위험성이 증가하고, 모든 요청에 대한 허용이란 의미는 구체적인 의미가 불분명하다는 것이 되므로, 결국 보안정책 및 네트워크 관리가 복잡해짐을 나타낸다. 하지만 같은 네트워크 내에 존재하는 어떤 기기라도 서버로 접속이 가능하게되어, 개발 및 테스트 편의성 및 접근성은 좋아지게 된다. 
4. 127.0.0.1 접속 vs 내부 IP 접속 차이
    - 127.0.0.1 접속 : localhost 또는 루프백(Loopback) 주소라고도 한다. 즉, 자기자신을 가리키는 특별한 IP주소로서 오직 해당 컴퓨터 내부에서만 접속이 가능하다. 그렇기에 개발자가 자기 자신의 컴퓨터에 접속하여 테스트할 때 사용하며 기타 네트워크를 거치지 않기에 속도 또한 빠르다.
    - 내부 IP 접속 : 사설IP라고도 불리며, 라우터(공유기)가 각각의 기기에 할당해주는 내부 네트워크용 주소이다. 동일한 라우터에 연결된 모든 기기는 서로에게 접근할 수 있으며, 내부 네트워크 내에서의 기기간 통신이 필요할 때에 사용 가능하다. 
5. 포트 번호의 의미와 기본 충돌 시 해결 방안
    - IP가 특정 컴퓨터의 주소라고 할 경우, 포트번호는 그 컴퓨터 안에서 실행되고 있는 프로그램의 고유 번호이다. 하나의 컴퓨터에서 다양한 프로그램이 동시에 실행 될 때, 각각의 데이터가 해당 프로그램을 찾아갈 수 있도록 한다. 혹시라도 2개 이상의 프로그램에서 동일한 포트번호를 사용하게 될 경우에 충돌이 발생하며, 포트번호 충돌이 발생할 경우 어떤 프로그램에서 특정 포트번호를 사용하는지 확인한 다음에, 해당 프로그램을 강제종료 하는 방법이 있다. 강제종료 이후에 강제종료한 프로그램을 다시 실행할 경우에는 충돌하지 않는 포트 번호를 할당하여 충돌을 피하도록 해야한다.  
    - 리눅스/macOS: lsof -i :포트번호 또는 netstat -anp | grep 포트번호 명령어로 어떤 프로세스가 포트를 점유하고 있는지 확인 후 kill 명령어로 종료할 수 있습니다.
    - Windows: netstat -ano | findstr :포트번호 명령어로 PID(프로세스 ID)를 찾고, 작업 관리자에서 해당 PID를 찾아 종료할 수 있습니다. 

